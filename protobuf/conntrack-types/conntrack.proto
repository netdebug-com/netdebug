syntax = "proto3";

package conntrack;

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

message IpAddr {
    oneof ip {
        fixed32 v4 = 1;
        bytes v6 = 2;
    }
}

enum MeasurementType {
    UnspecifiedMeasurementType = 0;
    FromDesktop = 1;
    FromServer = 2;
}

enum ProbeType {
    // Note, enum variants need to unique across the whole package, not just
    // per enum type (thanks C++).
    UnspecifiedProbeType = 0;
    RouterReplyFound = 1;
    RouterReplyNoProbe = 2;
    NatReplyFound = 3;
    NatReplyNoProbe = 4;
    EndHostReplyFound = 5;
    EndHostReplyNoProbe = 6;
    NoReply = 7;
}

message Probe {
    ProbeType probe_type = 1;
    uint32 outgoing_ttl = 2;
    optional google.protobuf.Timestamp out_timestamp = 3;
    optional google.protobuf.Timestamp in_timestamp = 4;
    optional IpAddr sender_ip = 5;
    // The TTL in the probe response we received. Allows us to guess
    // the distance the respone packet has travelled
    // Not sure if this is useful to infer assymteric routing
    optional uint32 received_ttl_remaining = 6;
    optional string comment = 7;
}

message ProbeRoundReport {
    uint32 probe_round = 1;
    optional google.protobuf.Duration application_rtt = 2;
    repeated Probe probes = 3;
}

message ProcessInfo {
    uint32 pid = 1;
    optional string process_name = 2;
}

message ConnectionStorageEntry {
    MeasurementType measurement_type = 1;
    optional string local_hostname = 2;
    IpAddr local_ip = 3;
    uint32 local_port = 4;

    optional string remote_hostname = 5;
    IpAddr remote_ip = 6;
    uint32 remote_port = 7;

    uint32 ip_proto = 8;

    repeated ProbeRoundReport probe_rounds = 9;

    optional string user_annotation = 10;
    optional string user_agent = 11;
    repeated ProcessInfo associated_apps = 12;
}
